Mini-DERMS Feeder Controller – Design Document
1. Purpose and Scope

Mini-DERMS Feeder Controller is a small, end-to-end demo of a feeder-level DERMS system that now supports multiple feeders and authenticated operator workflows.

It simulates distributed energy resources (DERs): PV, batteries, EV chargers, and physical Pi-based agents, grouped by feeder and optionally nested through parent feeders.

It ingests telemetry via MQTT, persists it in PostgreSQL, and exposes a REST API.

It runs a periodic control loop per feeder that enforces configurable feeder limits, applies DR programs, and can use either a heuristic allocator or an optimizer-backed allocator.

It ships with a React dashboard that visualizes current feeder load, device status, tracking-error/SOC metrics, and lets an operator create DR events through a small web form and login flow.

This is a teaching/demo system, not production deployment.

What’s new / capabilities

- Multi-feeder topology: devices carry feeder_id/parent_feeder_id and the control loop iterates per feeder.
- Authentication and roles: JWT guard protecting API routes with viewer/operator/admin roles.
- Optimizer-based allocation: optional LP solver path alongside the weighted heuristic allocator.
- Physical DER agents: Pi-based devices highlighted in the dashboard with origin filters and tracking-error metrics.

Non-goals (still out of scope)

- Full distribution network power-flow modeling or voltage-aware constraints.
- Market bidding/settlement or utility integration beyond simple DR programs.
- High-availability production hardening; this remains a local/demo stack.

2. High-Level Architecture

Technologies

Simulator: Python (paho-mqtt) publishing telemetry and obeying control commands.

Message bus: MQTT (Mosquitto) at localhost:1883.

Backend: Node.js + TypeScript + Express + pg (PostgreSQL client) + mqtt.

Database: PostgreSQL with three main tables (devices, telemetry, events).

Frontend: React + TypeScript + Vite.

Data & Control Flow

Simulator / Pi agents → MQTT

PV, battery, and multiple EV chargers (simulated or physical) periodically publish telemetry to:

der/telemetry/<deviceId> (JSON payload). Each payload includes feeder_id and optional parent_feeder_id so devices can be grouped across multiple feeders.

MQTT → Backend → Postgres

Backend’s MQTT client subscribes to der/telemetry/#.

For each message:

Parse JSON.

Best-effort upsert device metadata into devices (including feeder_id, priority, and whether the device is physical).

Insert a row into telemetry (time-series).

DB → Control Loop → MQTT

Periodic control loop runs per active feeder id:

Queries latest telemetry for that feeder’s devices.

Computes total feeder kW vs current limit and demand-response program.

Allocates allowed kW across dispatchable devices using a weighted heuristic or optimizer-backed allocator.

Publishes setpoints on der/control/<deviceId> as JSON.

MQTT → Simulator / Pi agents

Simulator subscribes to der/control/#.

For EVs, it ramps p_actual_kw toward the commanded p_setpoint_kw with a simple dynamic model and noise; Pi agents respond directly to setpoints.

Backend → Frontend

React dashboard polls:

GET /api/feeder/summary (optionally per feeder)

GET /api/devices

GET /api/metrics/tracking-error and other charts

A small form calls:

POST /api/events to create DR events after authenticating.

3. Backend Architecture
3.1 Startup & Wiring (src/index.ts)

Responsibilities:

Load configuration (config.ts).

Initialize database schema (initSchema from db.ts).

Start MQTT client (startMqttClient), non-blocking.

Configure and start Express:

Middleware: CORS, JSON body parsing.

Routes:

GET /api/health

GET /api/openapi.json and /api/docs for Swagger UI

POST /api/auth/login (before auth guard)

app.use('/api', requireAuth) applies JWT guard to the rest.

Routers for feeder (summary/history/metrics/feeders), devices, telemetry, events, simulation helpers, DR programs, and metrics (tracking-error).

Start the control loop (startControlLoop) after DB and MQTT are ready.

Listen on config.port (e.g., http://localhost:3001).

This file is intentionally thin; all logic is delegated to modules.

3.2 Configuration (src/config.ts)

Loads environment variables via dotenv and provides typed defaults:

HTTP server:

PORT (default 3001).

Postgres:

DB_HOST, DB_PORT, DB_USER, DB_PASSWORD, DB_NAME.

MQTT:

MQTT_HOST, MQTT_PORT.

Control behavior:

CONTROL_INTERVAL_SECONDS (e.g., 60s).

FEEDER_DEFAULT_LIMIT_KW and DEFAULT_FEEDER_ID to seed multi-feeder runs.

CONTROL_GLOBAL_KW_LIMIT, CONTROL_MIN_SOC_RESERVE, CONTROL_TARGET_SOC, CONTROL_SOC_WEIGHT, CONTROL_RESPECT_PRIORITY tune the allocator.

CONTROL_ALLOCATION_MODE and CONTROL_OPTIMIZER_* toggle the optimizer path (javascript-lp-solver) vs heuristic.

Tracking metrics:

TRACKING_ERROR_WINDOW_MINUTES controls rolling tracking-error calculations.

Authentication:

JWT_SECRET, JWT_TOKEN_TTL_HOURS, and AUTH_USERS (JSON array of username/password/role) define the login guard. JWT_SECRET and
AUTH_USERS must be injected via environment variables or a secret manager; the backend refuses to start if they are missing,
weak, or improperly formatted. Passwords are validated for complexity (12+ chars, mixed case, number, symbol) to reduce weak
defaults.

Exposes a config object used everywhere else; secrets are sourced externally per the README to avoid embedded credentials.

3.3 Persistence Layer (src/db.ts)

Builds a pg.Pool using configuration.

On startup, executes DDL to create tables if absent:

devices

id (PK, text, e.g., ev-001)

type (pv, battery, ev, …)

site_id (text)

feeder_id (text, defaults to DEFAULT_FEEDER_ID) with optional parent_feeder_id for hierarchy

p_max_kw (numeric)

priority (integer) and is_physical flags

telemetry

id (PK, serial)

device_id (FK → devices.id)

feeder_id (text)

ts (timestamp with time zone)

type

p_actual_kw (numeric)

p_setpoint_kw (numeric, nullable)

soc (numeric, nullable)

site_id

weather/irradiance estimates for PV (cloud_cover_pct, shortwave_radiation_wm2, estimated_power_w)

events

id (PK, serial)

feeder_id (text)

ts_start (timestamptz)

ts_end (timestamptz)

limit_kw (numeric)

type (e.g., 'dr')

dr_programs

id (PK, serial)

name, mode, window (ts_start/ts_end), target_shed_kw, incentive/penalty knobs, is_active

Exposes a small query(sql, params) helper used by repository modules.

Enforces referential integrity via foreign keys (telemetry rows must reference an existing device).

3.4 Repository Layer

Repositories hide raw SQL and provide logical operations.

src/repositories/devicesRepo.ts

upsertDevice(deviceId, type, siteId, pMaxKw)
Insert or update devices when new telemetry arrives.

getAllDevices()
Returns all device rows (used by /api/devices and control loop).

src/repositories/telemetryRepo.ts

insertTelemetry(row: TelemetryRowInput)
Writes a new telemetry record.

getLatestTelemetryPerDevice()
Latest row per device_id, used for:

feeder summary,

device list,

control loop.

getRecentTelemetry(deviceId, limit)
Recent time-series for charting or debugging.

src/repositories/eventsRepo.ts

createEvent({ tsStart, tsEnd, limitKw, type })
Inserts a new DR event with basic validation (tsStart < tsEnd, limit ≥ 0).

getActiveEvents(now: Date)
Returns all events where ts_start <= now <= ts_end.

getCurrentFeederLimit(now: Date)

If one or more active events exist:

Returns the minimum limit_kw (most restrictive).

Else:

Returns config.feederDefaultLimitKw.

3.5 MQTT Ingestion (src/mqttClient.ts)

Creates a single shared mqttClient instance:

Connects to mqtt://MQTT_HOST:MQTT_PORT.

On connect:

Subscribes to der/telemetry/#.

On message for der/telemetry/<deviceId>:

Parse JSON payload, expecting fields like:

deviceId, type, timestamp, p_actual_kw, soc, site_id, p_max_kw, p_setpoint_kw.

Call upsertDevice(deviceId, type, site_id, p_max_kw) (best effort; errors logged but do not crash).

Call insertTelemetry(...) to persist the time-series point.

Log and continue if insert fails (e.g., if device row isn’t present yet).

Connection is non-blocking:

The HTTP server and control loop can start even if the broker is temporarily unavailable.

Errors are logged but do not bring down the process.

3.6 Control Loop (src/controllers/controlLoop.ts)

Runs periodically to enforce feeder limits by adjusting dispatchable setpoints (primarily EVs) for each active feeder.

Inputs per tick

now = new Date()

feederIds = getFeederIds() (defaults to DEFAULT_FEEDER_ID if none are registered)

limitKw = getCurrentFeederLimit(now, feederId) (includes active DR events)

latest = getLatestTelemetryPerDevice(feederId)

devices = getAllDevices()

Derived values

Join devices + latest on id to build DeviceState objects including feederId, priority, pMaxKw, SOC, physical/simulated flags, and current setpoint estimates.

Filter dispatchable devices (EVs + batteries) and partition per feeder.

Compute per-feeder totals and availableForEv = max(min(limitKw, CONTROL_GLOBAL_KW_LIMIT) - nonEvKw, 0).

If an active DR program exists, adjust availableForEv using elasticity/price knobs and record per-device utilization metrics.

Allocation path

- computeAllowedShares mixes long-lived deficits, device priority, SOC gap from reserve/target, and optional optimizer mode.
- If CONTROL_ALLOCATION_MODE=optimizer and javascript-lp-solver is present/enabled, build and solve an LP with feeder cap + device caps; fall back to heuristic if infeasible.
- Heuristic mode sorts by deficit/weight, fills allocations, then backfills remaining headroom.

Publishing & monitoring

- Commands ramp toward targets with a fixed step to avoid oscillation.
- deviceSetpoints/deviceDeficits maps persist across ticks to smooth control.
- Records tracking-error samples and DR impact telemetry for dashboards.
- Offline/stalled-loop detection triggers warning logs/alerts; MQTT publishes setpoints when connected.

This loop turns DR events, feeder limits, and optimizer/heuristic policy into concrete kW setpoints for each feeder’s dispatchable devices.

3.7 HTTP API Surface

Authentication

POST /api/auth/login
→ { token, user: { username, role } } using configured AUTH_USERS. All other routes (except /api/health and /api/openapi.json) require a bearer token.

Health

GET /api/health
→ { status, db, mqtt, controlLoop } including offline device counts and stalled-loop status.

Feeder

GET /api/feeder/summary?feederId=<id>
Returns current totalKw, limitKw, deviceCount, and by-type aggregates for the selected feeder.

GET /api/feeder/history?minutes=30&bucketSeconds=60&feederId=<id>
Downsampled feeder totals over time plus current limit.

GET /api/feeder/metrics?window=day&bucketMinutes=60&feederId=<id>
Aggregated utilization metrics for charts.

GET /api/feeder/feeders
Lists known feeders with parent relationships and device counts.

Devices

GET /api/devices
Returns devices with latest telemetry, feeder metadata, priority, and physical/simulated flag.

Telemetry

GET /api/telemetry/:deviceId
Returns recent history for a single device (e.g., N most recent points), used for debugging or future charts.

Events & DR programs

POST /api/events
Create a DR event window with a new feeder limit (enforced by auth role guards).

GET /api/events
List current/past events.

GET /api/dr-programs and POST /api/dr-programs
Inspect or create dynamic DR programs that influence allocation elasticity.

Metrics

GET /api/metrics/tracking-error
Rolling average of p_actual_kw - p_setpoint_kw per device, used by the dashboard.

4. Frontend (Dashboard) Design
4.1 Structure

Single-page React app built with Vite + TypeScript:

src/main.tsx – bootstraps React root.

src/App.tsx – wraps the Dashboard page.

src/pages/Dashboard.tsx – top-level layout and polling logic.

src/api/types.ts – TypeScript types for API responses.

src/api/client.ts – fetch helpers (fetchFeederSummary, fetchDevices, createDrEvent).

Components:

FeederSummary.tsx – summary card with total kW, limit, device count, and by-type chips.

FeederChart.tsx – simple horizontal bar showing totalKw / limitKw.

DeviceTable.tsx – table of devices (ID, type, site, p_actual_kw, p_max_kw, SOC, last updated).

DrEventForm.tsx – small card to create DR events.

Styling: src/styles.css for basic card/tables/layout styling.

The dashboard now starts with a login screen (viewer/operator/admin), highlights physical Pi-based devices, and layers in filters plus SOC/tracking-error visualizations to match the upgraded backend metrics.

4.2 Polling and State

Dashboard:

Maintains local state:

summary: FeederSummary | null

devices: DeviceWithLatest[]

loading / error flags.

On mount:

Immediately fetches summary + devices.

Sets up a polling interval (~8 seconds) to refresh both.

On unmount:

Clears the polling interval.

The polling interval ensures the UI stays in sync with the latest telemetry and control decisions.

4.3 DR Event Form

DrEventForm:

Inputs:

limitKw (number input).

durationMinutes (number input).

On submit:

Validate both > 0.

Compute:

const now = new Date();
const tsStart = now.toISOString();
const tsEnd = new Date(now.getTime() + durationMinutes * 60 * 1000).toISOString();


Call createDrEvent({ limitKw, durationMinutes }) which POSTs /api/events.

Show a success or error message inline.

Optionally trigger a one-off refetch of summary/devices in the parent.

This replaces manual curl calls and makes the DR event behavior more visible and testable.

5. Simulator Design

simulator/simulator.py:

Uses paho.mqtt.client to connect to localhost:1883.

Device set

pv-001 (type "pv", site house-01, p_max_kw ~ 5)

bat-001 (type "battery", site house-01, p_max_kw ~ 4)

ev-001..ev-004 (type "ev", mixed p_max_kw values and sites).

State tracking

Per-battery SOC map (0–1).

Per-EV:

SETPOINTS[deviceId] – last commanded p_setpoint_kw.

LAST_P_ACTUAL[deviceId] – previous step’s p_actual_kw.

MQTT handlers

on_connect:

Logs connection.

Subscribes to der/control/#.

on_message:

For topics der/control/<deviceId>:

Parse JSON.

If p_setpoint_kw present and numeric:

Store in SETPOINTS[deviceId].

Log [sim] control msg ev-002 setpoint -> 3.5 kW.

Main loop

Every few seconds:

For PV:

p_actual_kw generated as noisy value ∈ [0, p_max_kw] (rough sunlight approximation).

For battery:

p_actual_kw random around 0 (charging/discharging).

SOC updated via simple energy balance.

For each EV:

If a setpoint exists:

Clamp to [0, p_max_kw].

Move LAST_P_ACTUAL toward setpoint at a fixed ramp rate (±1 kW per step) plus small random noise.

Else:

Use a default random charging behavior.

Publish telemetry payloads to der/telemetry/<deviceId> as JSON.

This creates visible dynamics for the controller and dashboard to react to.

6. Operational Notes
6.1 Dependencies

Postgres running locally with a mini_derms database and appropriate credentials (as in .env).

Mosquitto MQTT broker on localhost:1883.

Node.js and npm installed.

Python 3.12 + virtualenv for the simulator.

6.2 Typical Local Dev Workflow

Backend

cd Mini-DERMS-Feeder-Controller
npm install
npm run dev          # ts-node-dev, auto-reload


Simulator

cd Mini-DERMS-Feeder-Controller
python3 -m venv .venv
source .venv/bin/activate
pip install -r simulator/requirements.txt
cd simulator
python simulator.py


Frontend

cd Mini-DERMS-Feeder-Controller/frontend
npm install
npm run dev          # Vite at http://localhost:5173


Navigate to http://localhost:5173 to see:

Feeder summary and load bar.

Device table with PV, battery, and EVs.

“Create DR Event” form to apply new feeder limits.
